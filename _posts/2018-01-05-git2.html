---
layout: post
title:  "Git第二章"
date:   2018-01-05 23:09:13 -0400
background: '/img/posts/01.jpg'
comments: true
---
<h1>Git第二章</h1>
<hr />
<blockquote>
<p>既然已经知道git在我们磁盘上的存储区域，并能对我们的修改进行简单的管理，接下来就是更详细了解git的强大功能。</p>
</blockquote>
<h2>目录</h2>
<ul>
<li><a href="#分支的创建&amp;合并" title="分支的创建&amp;合并">分支的创建&amp;合并</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#最小单位" title="最小单位">最小单位</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#创建分支" title="创建分支">创建分支</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#切换分支" title="切换分支">切换分支</a> <br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#合并分支" title="合并分支">合并分支</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#合并分支的两种情况" title="合并分支的两种情况">合并分支的两种情况</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#合并分支的两种命令" title="合并分支的两种命令">合并分支的两种命令</a> <br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#分支的作用" title="分支的作用">分支的作用</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#并行方式的场景应用" title="并行方式的场景应用">并行方式的场景应用</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#主从方式的场景应用" title="主从方式的场景应用">主从方式的场景应用</a>  
</li>
<li><a href="#远程仓库&amp;分支" title="远程仓库&amp;分支">远程仓库&amp;分支</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#创建远程仓库" title="创建远程仓库">创建远程仓库</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#克隆远程分支" title="克隆远程分支">克隆远程分支</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#同步远程分支上的修改" title="同步远程分支上的修改">同步远程分支上的修改</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#同步&amp;合并远程分支上的修改" title="同步&amp;合并远程分支上的修改">同步&amp;合并远程分支上的修改</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#推送本地更新至远程分支" title="推送本地更新至远程分支">推送本地更新至远程分支</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#本地分支与远程分支的关联" title="本地分支与远程分支的关联">本地分支与远程分支的关联</a><br />
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#远程分支提交历史的偏离" title="远程分支提交历史的偏离">远程分支提交历史的偏离</a></li>
</ul>
<h2><a name="分支的创建&amp;合并">分支的创建&amp;合并</a></h2>
<blockquote>
<p>分支指的是git在版本库为我们创建的master分支和我们自己手动创建的其他分支。git的分支合并切换十分快速，因此提倡新功能或是bug修复都通过新建分支，在新分支中完成后再合并到我们的主分支上。这样可以避免提交半成品至主分支上而耽误其他人的协作开发。</p>
</blockquote>
<h3><a name="最小单位">最小单位</a></h3>
<p>分支的最小单位是一个Commit，我们可以在多个Commit中快速的后退和前进。因此在Commit提交时一定要带上描述参数<code>-m</code>，用合适的描述来说明提交Commit修改了什么内容。假设我们在提交了两个Commit后(提交命令为<code>git commit -m &quot;修改描述&quot;</code>)，即C1和C2，再提交一个C3，将这些Commit放在时间线上的变化大概是这样的：</p>
<img src="/img/git/commit.png" alt="Commit示意图" title="Commit示意图" />
<blockquote>
<p>注意：该图中会出现两个指针，HEAD和Master，HEAD指针指向的是我们当前工作空间，Master指针标识的是当前该分支上的最新一个Commit。而HEAD指针指向Master指针，则标识我们当前的工作空间是在Master分支上的最新一个Commit开始修改。像C1这样的标识在图中只是缩写，在实际环境中会替换成一串很长的Commit ID。</p>
</blockquote>
<p>那版本回退又是怎么样的呢，我们从提交C3回退至C2(回退命令为<code>git reset HEAD^</code>),版本回退在时间线上的变化大概是这样的：</p>
<img src="/img/git/reset.png" alt="回退示意图" title="回退示意图" />
<blockquote>
<p>注意：我们当前工作空间会从Master分支上的C3回退到C2。图中其实会发生两个变化，一个是Master指针会从C3指向C2，第二个是HEAD会跟着指向Master分支指针。版本的前进与回退相似，这里就不再演示了。</p>
</blockquote>
<h3><a name="创建分支">创建分支</a></h3>
<blockquote>
<p>在我们上文中提到，分支不过是一个指向提交的指针，因此创建分支，就是创建一个分支指针。  
</p>
</blockquote>
<p>git创建分支可以通过键入<code>git branch &lt;分支名称&gt;</code>来完成。假设我们已经在分支上提交了三个Commit，接下来我们在最新的Commit C3上创建一个分支<code>Dev</code>，在时间线上的变化如下：</p>
<img src="/img/git/branch-create.png" alt="分支创建示意图" title="分支创建示意图" />
<h3><a name="切换分支">切换分支</a></h3>
<p>在git中切换分支不过是改变指针的指向，即将HEAD指针指向我们创建的分支指针上。如切换至上文创建的<code>Dev</code>，键入命令<code>git checkout Dev</code>分支在时间线上的变化如下：</p>
<img src="/img/git/switch-branch.png" alt="分支切换示意图" title="分支切换示意图" />
<p>接下来我们在上文的基础上分别在<code>Dev</code>分支上提交一个Commit，然后切换回<code>Master</code>分支后再提交一个Commit，在时间线上的变化如下：</p>
<img src="/img/git/switch&amp;commit.png" alt="分支切换和提交" title="分支切换和提交" />
<blockquote>
<p>我们还可以通过<code>git checkout -b &lt;分支名称&gt;</code>命令同时执行创建和切换两条命令。</p>
</blockquote>
<h3><a name="合并分支">合并分支</a></h3>
<blockquote>
<p>分支的合并有两种情况和两种命令。</p>
</blockquote>
<p>通过上文的介绍我们已经能够灵活的游走在各个分支间了，接下来就是将各个分支上的内容合并起来了。
分支的使用方式大概有两种，一种是主从方式，另一种为并行方式。两种方式的使用场景和作用会在下文中提及。这里我们的分支合并主要针对主从方式。</p>
<h4><a name="合并分支的两种情况">合并分支的两种情况</a></h4>
<p>合并分支可以在主分支上通过键入<code>git merge &lt;从分支名称&gt;</code>来合并分支内容。如上文的<code>Master</code>主分支和<code>Dev</code>从分支。</p>
<blockquote>
<p>注意：这里的主从分支并不一定是指<code>Master</code>分支和其他分支。而是分支合并中的主从关系。</p>
</blockquote>
<ol>
<li>
<p>第一种情况：合并的从分支是在当前主分支基础上创建的，并且从分支仅比当前分支新提交了一个Commit或多个Commit，git直接将主分支的分支指针指向从分支最新的Commit，此为fast-forward方式。默认在该情况下会采用fast-forward的合并方式，当然也能够通过<code>--no-ff</code>参数来关闭fast-forward方式。</p>
</li>
<li>
<p>第二种情况：合并的目标分支是在当前分支的旧Commit基础上创建的，并且比主分支的最新Commit新提交了一个或多个Commit，git会采用非fast-forward方式合并分支内容。非fast-forward方式会尝试将两个分支上不同的commit合并一起后自动提交一个新的commit。如将上文的<code>Dev</code>分支上的改动合并到<code>Master</code>分支上，形成提交树。在提交树上大概是这样的。</p>
</li>
</ol>
<img src="/img/git/merge.png" alt="Merge分支合并示意图" title="Merge分支合并示意图" />
<blockquote>
<p>
注意：用命令<code>merge</code>合并分支，需要先通过<code>checkout</code>命令切换到主分支上。合并完成后，可以通过<code>git branch -d &lt;分支名称&gt;</code>来删除无用的分支。
图中带`C4'`号的Commit仅是为了更加鲜明的表示分支合并的变化，实际上还是指向`C4`。
</p>
</blockquote>
<h4><a name="合并分支的两种命令">合并分支的两种命令</a></h4>
<p>分支合并可以通过<code>git merge &lt;从分支名称&gt;</code>和<code>git rebase &lt;主分支名称&gt;</code>命令来完成。前面已经介绍了<code>merge</code>命令，接下来我们来使用<code>rebase</code>。<br />
上文中Merge合并示意图中我们会看到，<code>Master</code>分支会将<code>Dev</code>分支上的内容合并到自己的Commit时间线上，从而形成Commit提交树。而通过Rebase合并则不会形成Commit提交树，而是让不同分支上的Commit合并到同一条时间线上，就像是在同一条分支上开发的一样。如通过Rebase方式将<code>Dev</code>合并到<code>Master</code>分支上。在时间线上大概是这样的。</p>
<img src="/img/git/rebase.png" alt="Rebase分支合并示意图" title="Rebase分支合并示意图" />
<blockquote>
<p>注意：用命令<code>rebase</code>合并分支，需要先通过<code>checkout</code>命令切换到从分支上。Rebase合并方式的缺点是在时间线上的提交并不是顺序的。</p>
</blockquote>
<h3><a name="分支的作用">分支的作用</a></h3>
<blockquote>
<p>通过上文的介绍，相信我们已经基本掌握了分支的创建和合并。花费大量的篇章和图文去讲述分支在git中的应用。自然分支在git中是十分重要的。</p>
</blockquote>
<p>分支对于团队来说是十分有用的。</p>
<h5><a name="并行方式的场景应用">并行方式的场景应用</a></h5>
<p>我们可以通过创建两条分支来并行开发两个差异较大的版本。如我们在1.0版本的基础上来开发1.1版本修复一些问题，使我们的代码更加稳定即维护现有版本。同时创建一条新的分支，在1.0版本的基础上开发2.0版本引入新的特性。</p>
<h5><a name="主从方式的场景应用">主从方式的场景应用</a></h5>
<ul>
<li>
<p>分支策略，
通常我们在日常开发中的分支策略是维护一条版本稳定的Master分支，同时维护一条版本不稳定即随时新增或提交bug修复的dev分支。而我们日常开发的提交自然是在dev分支上进行的。只有要发布阶段性的版本的时候才会将Dev分支合并到Master上，以此来保证Master分支的可用性和完整性。</p>
</li>
<li>
<p>提高团队合作效率和代码安全性，同样的我们在开发新功能或修复bug的时候可以在本地创建分支来进行，这样的好处是可以不影响他人，也可以随时保存和提交我们的修改来提高代码的安全性。git分支的应用可以大大提高团队的合作效率。</p>
</li>
<li>开源项目的参与方式，git分支实际上极大的推动了开源项目的发展，如我们可以从Github上fork下某个开源项目的master分支，在本地创建自己的分支，待分支开发和测试完成后可以向开源项目的管理者提交一个merge请求，以此达到参与开源项目的过程。</li>
</ul>
<h2><a name="远程仓库&amp;分支">远程仓库&amp;分支</a></h2>
<p>其实远程仓库仅仅是本地仓库在另一台计算机上的拷贝而已，它们之间通过互联网来通讯-添加和下载提交记录（同步）。但远程仓库却拥有着十分强大的属性。</p>
<ul>
<li>容灾备份：远程仓库可以起到容灾备份的作用，当我们的本地硬盘发生了不可预测的损坏时，我们仅需要从远程仓库拷贝一份即可恢复。</li>
<li>项目代码社交化：既然我们项目和代码托管在了远程仓库，一般是托管在像Github或Phabricator这样的网站上，即公开了我们的项目和代码。这样我们的朋友就可以为项目作出贡献或是可以查看我们最新的修改。这样就就可以顺利成章的进行团队合作。</li>
<li>可视化操作：我们可以直接在Github或Phabricator上进行可视化操作。如wiki的编辑，项目描述的编辑等。</li>
</ul>
<h3><a name="创建远程仓库">创建远程仓库</a></h3>
<blockquote>
<p>创建远程仓库前需要创建一个账号，这里以Github为例。拥有账号后才能在Github上创建我们的远程仓库和远程分支。</p>
</blockquote>
<p>我们本地仓库与远程仓库通讯是通过<code>SSH</code>加密传输的，因此得先在本地创建SSH Key。在任一文件夹中调出git命令行界面，键入以下命令。</p>
<pre><code>ssh-keygen -t rsa -C &quot;youremail@163.com&quot;
</code></pre>

<blockquote>
<p>注意：该命令中<code>-C</code>参数为大写，将<code>&quot;youremail@163.com&quot;</code>更换为你在上文中（<a href="https://347255699.github.io/2017/12/23/git.html" title="Git第一章">Git第一章</a>）中注册的邮箱标识。然后一路回车即可，无需设置密码。</p>
</blockquote>
<p>命令运行完成后会在我们C盘用户目录下生成一个<code>.ssh</code>文件夹，该文件夹下会存在两个文件。<code>id_rsa</code>和<code>id_rsa.pub</code>，分别为SSH私钥和公钥。而我们需要将公钥中的内容配置到github网站上才能开始创建远程仓库。github上的SSH Key配置位置为：个人头像/Settings/SSH and GPG Keys/New SSH Key。如下图所示：</p>
<img src="/img/git/ssh-key.png" alt="SSH Key添加示意图" title="Key添加示意图" />
<p>创建远程仓库，在github首页点击New repository即可创建我们的远程仓库。如下所示：</p>
<img src="/img/git/repository-create.png" alt="远程仓库创建示意图" title="远程仓库创建示意图" />
<blockquote>
<p>注意：可以勾选<code>Initialize this repository with a README</code>来创建项目描述文件（可以用markdown语法来编写项目介绍内容）</p>
</blockquote>
<p>创建完成后的可视化远程仓库：</p>
<img src="/img/git/repository-ui.png" alt="可视化远程仓库示意图" title="可视化远程仓库示意图" />
<h3><a name="克隆远程分支">克隆远程分支</a></h3>
<p>git中可以通过键入<code>git clone &lt;git远程仓库地址&gt;</code>命令在本地克隆远程仓库，远程仓库克隆完成后，git会自动在本地为我们创建远程分支。表现在时间线上大概是这样的。</p>
<img src="/img/git/clone.png" alt="clone示意图" title="clone示意图" />
<blockquote>
<p>git默认将远程仓库取名为Origin。</p>
</blockquote>
<p>我们在本地是无法在origin/master分支中提交Commit的，origin/master只由在远程仓库中对应的分支更新，才会更新。若我们通过<code>checkout</code>命令切换至origin/master后提交Commit,会使得HEAD指针与分支指针分离(该概念会在下一章中提及)。远程分支实际上反应了最近与远程仓库通讯后的状态。</p>
<h3><a name="同步远程分支上的修改">同步远程分支上的修改</a></h3>
<p>我们可以通过键入<code>git fetch</code>命令与远程仓库取得通信，fetch命令会扫描远程仓库上对应的分支和本地远程分支的差异，将远程仓库分支上的更新同步至本地远程分支，并将本地远程分支指针指向最新的Commit。但不会将最新的Commit合并到本地Master分支上，也不会移动Master分支的指针。表现在时间线上大概是这样的。</p>
<img src="/img/git/fetch.png" alt="fetch示意图" title="fetch示意图" />
<p>那么如何将远程分支上的更新同步到本地Master分支上呢？当然是通过合并分支了。如我们上文提及的<code>merge</code>和<code>rebase</code>。</p>
<blockquote>
<p>注意：与远程分支的通信不一定是远程Master分支，也可以是其他分支。可通过键入<code>git fetch &lt;远程仓库名&gt;&lt;远程分支名&gt;</code>来与远程仓库上的其他分支进行通信。下文中的<code>pull</code>和<code>push</code>命令也是如此。</p>
</blockquote>
<h3><a name="同步&amp;合并远程分支上的修改">同步&amp;合并远程分支上的修改</a></h3>
<p>同步和合并远程分支上的修改可以通过键入<code>git pull</code>命令来完成。pull命令其实就是合并了上文中同步远程分支更新的两个步骤，即通过<code>fetch</code>命令将更新同步到远程分支，再将远程分支的更新合并到Master分支中。
<code>pull</code>命令默认通过<code>merge</code>来合并本地分支和远程分支。也可以通过<code>--rebase</code>参数来指定合并方式。上文我们已经介绍了merge和rebase的区别。<code>pull</code>命令在时间线上的变化如下。</p>
<img src="/img/git/pull.png" alt="pull示意图" title="pull示意图" />
<blockquote>
<p>注意：由于远程分支是基于Master分支最新的Commit即C3修改，即远程分支新增了一个C4Commit，因此采用merge合并时仅需要将Master分支指针指向最新的C4Commit即可(fast-forward方式)。</p>
</blockquote>
<h3><a name="推送本地更新至远程分支">推送本地更新至远程分支</a></h3>
<p>我们可以通过键入<code>git push</code>命令来推送我们本地修改至远程分支上。<code>push</code>实际上将我们的修改推送到远程仓库上的分支后，同时会更新本地远程分支并将远程分支指向最新的Commit上。<code>push</code>在时间线上的表示如下：</p>
<img src="/img/git/push.png" alt="push示意图" title="push示意图" />
<h3><a name="本地分支与远程分支的关联">本地分支与远程分支的关联</a></h3>
<p>在上文中提及的<code>pull</code>和<code>push</code>能够体现出本地分支和远程分支的关联。</p>
<ul><li><code>pull</code>，提交记录会先被同步到远程分支上，再自动合并到本地分支上。隐含的合并目标分支由这个关联决定。</li>
  <li><code>push</code>，我们将本地更新提交至远程仓库分支上时，会同时更新本地的远程分支。隐含的更新本地的远程分支也是由这个关联决定的。</li></ul>
<p>这种关联关系其实是由&quot;remote tracking&quot;属性决定，若通过clone去克隆远程仓库的分支时，git会自动在本地建立这种隐含的关联关系。如本地Master和远程Master,git会设定本地Master去追踪远程Master。当然这种关系也可以由我们手动去设置。在创建和切换到新分支时，<br />
通过键入<code>git checkout -b &lt;本地分支名称&gt; &lt;远程分支名称&gt;</code>，如<code>git checkout -b side origin/master</code>来设置这种关联关系。这样就能让side分支去跟踪远程Master分支了。<br />
通过上述的命令，我们就能顺利与远程仓库进行通信了。</p>
<h3><a name="远程分支提交历史的偏离">远程分支提交历史的偏离</a></h3>
<p>当远程仓库不只与一个人通信时，就有可能会造成提交历史偏离。如下一个例子，当你与另外一个人同时基于远程仓库的现有版本进行新功能开发或bug修复时，此时另外一个人进行的是bug修复，会改动原先的代码。而你进行的则是新功能开发。而另一个人修改的代码正好与你开发的新功能重叠（假设你的新功能是建立在某些现有API之上的，刚好这部分的API被另一个人改动了，并且比你先提交至远程分支上。）时就会造成提交历史偏离。这时你的新功能开发完成后，想通过push进行提交，你会发现提交不了，并且git会提示你拉取这部分代码(另一个人的修改)，在本地与你的代码进行合并(若出现冲突，需要我们手动去删选这部分重叠的代码)。当然git会在冲突的代码处给出提示，至于是什么样的提示要由你自己去实践看看了。</p>
<blockquote>
<p>至此我们已经能够顺利使用git与他人进行协作开发了。当然git还有一些小技巧没有介绍。特别是深刻了解HEAD和分支指针，将在下一章提及。本文是基于<a href="https://learngitbranching.js.org/" title="learning git branch">learning git branch</a>游戏的体验结合相关教程的总结。</p>
</blockquote>
