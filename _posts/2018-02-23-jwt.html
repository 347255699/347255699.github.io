---
layout: post
title:  "JWT(rfc7519)简介"
date:   2018-02-23 16:13:13 -0400
background: '/img/posts/04.jpg'
comments: true
---
<h1>JWT(rfc7519)简介</h1>
<blockquote>
<p>由于http协议是无状态，因此需要引入额外的认证机制来维持用户状态，传统方式是采用Session(rfc3261)认证机制来实现。</p>
</blockquote>
<h2>传统Session认证机制</h2>
<p>传统的Session认证机制大致是这样的。用户首次登陆或访问服务端成功后，服务端存储一份用户登录信息副本，随后将该用户登录信息副本响应给浏览器，让浏览器在客户端生成cookie，客户端而后的每次请求都会附上cookie中的用户信息，让服务端可以与载入到内存中的用户信息副本进行比对以此来完成认证。</p>
<h3>传统Session认证机制缺陷</h3>
<ul>
<li>增加机器性能开销，单台服务器中的载入内存的用户登录信息副本数量会随着用户数量的剧增而增加，占用内存。</li>
<li>分布式中缺乏扩展性，分布式应用中，用户无法在任一台服务器上认证后即可访问其他服务器上的资源，应用缺乏扩展性。</li>
<li>安全性，由于用户的认证授权是基于cookie信息，若cookie遭到拦截，容易引发CSRF(Cross-site request forgery)攻击。</li>
</ul>
<h2>JWT鉴权机制</h2>
<p>JWT的鉴权流程大致是这样的：  
</p>
<ol>
<li>用户凭借账户和密码请求服务端</li>
<li>服务端校验用户账户和密码</li>
<li>服务端校验成功后颁发Token</li>
<li>客户端而后的每次请求都需要附上服务端颁发的Token</li>
<li>服务端校验客户端请求中的Token，若检验成功则相应数据</li>
</ol>
<blockquote>
<p>客户端携带的token需要保存在header中。另外服务端需要支持CORS(Cross-origin resources sharing)策略，一般添加该参数即可。</p>
</blockquote>
<pre><code>Access-Control-Allow-Origin:*
</code></pre>

<h3>JWT构成</h3>
<p>JWT由三部分信息构成，分别是header、payload和signature。这三部分信息均通过Base64编码后通过 <code>.</code> 拼接即可构成Token字符串。Token字符串看起来是这样的：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>

<h4>header</h4>
<p>header为Token的头部，用于声明Token类型和加密算法。声明类型一般为 <code>jwt</code>，声明加密算法一般直接使用 <code>HMAC SHA256</code>。header看起来是这样的：</p>
<pre><code>{
    'typ':'JWT',
    'alg':'HS256'
}
</code></pre>

<blockquote>
<p>通过base64编码后即可构成JWT第一部分的信息。</p>
</blockquote>
<h4>payload</h4>
<p>payload载荷，即token的核心信息。该部分用于存放有效信息，如用户信息和业务相关信息。该部分主要由三部分组成，分别是标准中注册的声明、公共的声明和私有的声明。</p>
<h5>标准中注册声明</h5>
<p>该声明非必须但推荐</p>
<ul>
<li>iss:jwt签发者</li>
<li>sub:jwt所面向的用户</li>
<li>aud:接收jwt的一方</li>
<li>exp:jwt的过期时间，这个过期时间必须大于签发的时间</li>
<li>nbf:定义在什么时间之前，该jwt是不可用的</li>
<li>iat:jwt的签发时间</li>
<li>jti:jwt的唯一身份标识，用于一次性token防止重放攻击</li>
</ul>
<h5>公共声明</h5>
<p>公共声明可以添加任何信息，一般为用户或是业务相关的信息。但不能存放敏感信息如密码等，该部分声明应视为明文，因为该部分信息均可在客户端逆转为明文。</p>
<h5>私有声明</h5>
<p>提供者和消费者所共同定义的声明，一般不建议存放敏感信息。</p>
<h4>signature</h4>
<p>该部分信息由三部分组成，分别是header(base64后)、payload(base64后)和secret(盐)。将编码后的header和payload通过 <code>.</code> 拼接成字符串，然后通过header中声明的加密算法加入secret(盐)后加密。</p>
<blockquote>
<p>最后将jwt的三部分，分别是header、payload和signature通过 <code>.</code> 拼接成Token。 </p>
</blockquote>
<h2>实际应用</h2>
<p>客户端在请求中加入Authorization，并加上标注，以Bearer+空格开头后接token字符串。看起来是这样的：</p>
<pre><code>headers: {
    'Authorization': 'Bearer ' + token
}
</code></pre>

<h2>总结</h2>
<p>该文为<a href="https://www.jianshu.com/p/576dbf44b2ae">《什么是 JWT -- JSON WEB TOKEN》</a>的简化笔记。</p>
<h3>JWT优点</h3>
<ul>
<li>夸语言支持，jwt以json为数据交换格式，因为json格式的简单易用，所以可以轻易进行跨语言支持。</li>
<li>扩展性，jwt payload可以存储一些业务所需要的非敏感信息。且不需要在具体的服务器载入用户信息副本，便于服务器扩展。</li>
<li>便捷性，jwt构成简单，字节占用小，便于传输。</li>
</ul>
<h3>注意事项</h3>
<ul>
<li>不应在jwt payload中存放敏感信息，该部分在客户端可逆转等同于明文。</li>
<li>服务端的secret私钥十分重要，不可泄露。</li>
<li>尽可能使用HTTPS(密文通讯增加Token的安全性)。</li>
</ul>